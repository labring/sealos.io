---
title: 'Deploying n8n with Docker: From Local Setups to a Radically Simple Cloud Alternative'
imageTitle: 'Deploy n8n with Docker and cloud alternatives'
description: 'Master n8n deployment from Docker basics to production-ready setups. Learn docker run, docker compose with PostgreSQL, and discover Sealos - the one-click cloud alternative that eliminates Docker complexity while delivering enterprise features.'
date: 2025-09-29
tags:
  [
    'n8n',
    'Docker',
    'docker compose',
    'workflow automation',
    'Sealos',
    'self-hosting',
    'PostgreSQL',
    'cloud deployment',
    'DevOps',
    'container orchestration',
  ]
authors: ['default']
---

import { DeployButton } from '@/components/ui/button'

Self-hosting the open-source automation platform n8n offers total control over your data, workflows, and costs. Docker provides the obvious pathâ€”a clean, isolated environment to run your instance. But this path is littered with hidden operational traps. The power of Docker often comes with a steep cost in complexity, from managing container configurations and databases to orchestrating updates and ensuring high availability.

This tax on productivity slows down even experienced developers.

This guide walks you through the standard methods for running n8n locally with Docker, covering the quick-start `docker run` command and a more robust `docker compose` setup. More importantly, it introduces a modern, cloud-native approach that gives you all the benefits of self-hosting without the operational headaches.

## Why Self-Host n8n with Docker?

Before diving into the "how," let's anchor the "why." Using Docker to run your own n8n instance offers several key advantages:

  * **Data Sovereignty**: Your workflow data, credentials, and execution logs remain entirely within your infrastructure.
  * **Cost-Effectiveness**: Run n8n on hardware you already own or on cost-effective cloud virtual machines, avoiding subscription fees.
  * **Total Customization**: You have complete control over n8n's configuration, environment variables, and versioning.
  * **Isolated Environment**: Docker containers package n8n and its dependencies, preventing conflicts with other applications on your server.

## Method 1: The Quick Start with `docker run`

The fastest way to get an n8n instance running is with a single `docker run` command. This method is ideal for testing, local development, or simple, single-user scenarios.

### Prerequisites

First, ensure you have [Docker](https://docs.docker.com/get-docker/) installed on your Mac, Windows, or Linux machine.

### Running the Container

Once Docker is ready, open your terminal and execute the following command. Remember to replace `<YOUR_TIMEZONE>` with your actual timezone (e.g., `America/New_York` or `Europe/Berlin`).

```bash
docker run -it --rm \
  --name n8n \
  -p 5678:5678 \
  -v n8n_data:/home/node/.n8n \
  -e GENERIC_TIMEZONE="<YOUR_TIMEZONE>" \
  -e TZ="<YOUR_TIMEZONE>" \
  docker.n8n.io/n8nio/n8n
```

Let's break down this command:

  * `docker run -it --rm`: Runs the container in interactive mode (`-it`) and automatically removes it on stop (`--rm`), perfect for testing.
  * `--name n8n`: Assigns a memorable name to your container.
  * `-p 5678:5678`: Maps port `5678` from your local machine to the container, allowing you to access the n8n UI.
  * `-v n8n_data:/home/node/.n8n`: This is crucial for data persistence. It creates a Docker volume named `n8n_data` to store your workflows, credentials, and execution data. Without it, you would lose all your work on restart.
  * `-e ...`: Sets environment variables for configuring the timezone.

Once the container starts, access your n8n instance at `http://localhost:5678`.

## Method 2: A Robust Setup with Docker Compose

While `docker run` is great for a quick start, a production-ready setup needs a persistent database like PostgreSQL instead of the default SQLite. Managing multiple related containers (like n8n and its database) is where Docker Compose excels. It allows you to define a multi-service application in a single `docker-compose.yml` file, simplifying management.

### Prerequisites

  * [Docker](https://docs.docker.com/get-docker/)
  * [Docker Compose](https://docs.docker.com/compose/install/) (included with Docker Desktop)

### Creating the Docker Compose File

1.  Create a new directory for your project (e.g., `my-n8n-stack`).
2.  Inside it, create a file named `docker-compose.yml`.
3.  Paste in the following configuration:

```yaml
version: '3.8'

services:
  n8n:
    image: docker.n8n.io/n8nio/n8n
    restart: always
    ports:
      - "127.0.0.1:5678:5678"
    environment:
      - QUEUE_HEALTH_CHECK_ACTIVE=true
      - N8N_ENFORCE_SETTINGS_FILE_PERMISSIONS=true
      - N8N_RUNNERS_ENABLED=true
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=${POSTGRES_DB}
      - DB_POSTGRESDB_USER=${POSTGRES_USER}
      - DB_POSTGRESDB_PASSWORD=${POSTGRES_PASSWORD}
      - GENERIC_TIMEZONE=America/New_York # Change this
      - TZ=America/New_York               # Change this
    volumes:
      - n8n_data:/home/node/.n8n
    depends_on:
      - postgres

  postgres:
    image: postgres:15
    restart: always
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  n8n_data:
  postgres_data:
```

4.  Next, create a `.env` file in the same directory to store your credentials. *Never hardcode secrets in your `docker-compose.yml` file*.

```ini
# .env file
POSTGRES_DB=n8n
POSTGRES_USER=n8nuser
POSTGRES_PASSWORD=a-very-secure-password
```

### Running the Stack

With both files in place, open your terminal in the project directory and run:

```bash
docker compose up -d
```

This command downloads the required images, creates the volumes, and starts both services in the background (`-d`). Your n8n instance, now backed by a robust PostgreSQL database, is available at `http://localhost:5678`.

## Beyond the Setup: The Operational Realities of Docker

Setting up n8n with Docker is clearly achievable. However, the real challenges emerge when you move from a local playground to a production environment:

  * **Configuration Sprawl**: A production-grade `docker-compose` file can become a monster, tangled with reverse proxies for SSL, complex networking rules, and dozens of environment variables.
  * **Accidental DBA Duty**: You are now a database administrator. You're responsible for updating PostgreSQL, managing backups, and securing its data.
  * **Fragile Updates**: Updating n8n means manually pulling the new Docker image, stopping the containers, and restarting them, hoping nothing breaks in the process.
  * **No Clear Path to Scale**: If your automation load grows, how do you scale? How do you ensure high availability and automatic recovery from a crash? Docker Compose offers no native answers.
  * **A Fragmented World**: You have to manage domains, SSL certificates, firewalls, and monitoring separately. Your n8n instance is just one piece of a large, disjointed puzzle.

This operational burden is a constant distraction from the real goal: *building powerful automations*.

## The Simpler Alternative: One-Click n8n on Sealos

What if you could gain the control of self-hosting without paying the complexity tax? What if you could deploy n8n to enterprise-grade infrastructure without touching a line of YAML or a Docker command? This is where **Sealos** comes in.

[Sealos](https://sealos.io) is a cloud operating system designed to make running cloud-native applications radically simple. It abstracts away the notorious complexity of Kubernetes, providing an intuitive interface for deploying applications like n8n from an App Store.

### Problem-Solution Fit: From Complexity to Simplicity

With Sealos, the challenges of Docker melt away:

  * **Zero Configuration**: Instead of writing complex `docker-compose` files, you launch n8n from the **Sealos App Store** in a few clicks.
  * **Managed Databases**: Need PostgreSQL? Deploy it from the App Store. Sealos manages its lifecycle and simplifies connections.
  * **Automatic Public Domain & HTTPS**: Every application gets a public domain and an auto-configured SSL certificate, ready for webhooks out of the box.
  * **Built-in Scalability & High Availability**: Built on Kubernetes, your applications are inherently resilient. Scale them with a slider and let the system automatically restart them if they fail.

### Deploy n8n on Sealos in Under a Minute

The fastest way to get started is by using the **Deploy on Sealos** button, which takes you directly to a pre-configured n8n template.

<DeployButton deployUrl="https://sealos.io/products/app-store/n8n" />

1.  After clicking the button above, select **"Deploy Now"**.
      * If you're new to Sealos, you'll be prompted to create a free account and log in. You will then be redirected back to the template.
2.  **Configure Your Project**. On the deployment page, you can customize your n8n instance. Key options include:
      * **Use PostgreSQL**: Check the box for "Use PostgreSQL database for production workloads." This is highly recommended for better performance and data persistence.
      * **Enable Queue Mode**: For advanced use cases, you can select "Enable queue mode with Redis and workers for improved scalability and parallel execution." Note that this option requires PostgreSQL to be enabled.
3.  Click **"Deploy App"** to start the deployment.
4.  Once the process is complete, click on the application's **"Details"** to find the public URL. Your n8n instance is now live.

That's it. In under a minute, Sealos provisions and deploys a production-ready n8n instance with a public URL and a valid SSL certificate. No command line, no YAML, no complexity.

Sealos also supports custom domains. After deployment, you can update the application to add your domain and then adjust the `WEBHOOK_URL` environment variable to match.

## Comparison: Docker CLI vs. Docker Compose vs. Sealos

This table highlights the stark difference in user experience and required expertise.

| Feature                 | `docker run` (CLI)              | `docker compose`                | Sealos Platform                       |
| ----------------------- | ------------------------------- | ------------------------------- | ------------------------------------- |
| **Setup Complexity** | Low (for single container)      | Medium to High (YAML files)     | **Zero** (1-Click from App Store)     |
| **Database Integration**| Manual container linking        | Defined in YAML, still manual   | **1-Click Database Deployment** |
| **Public Access (HTTPS)**| Requires external tools (ngrok) | Requires manual reverse proxy   | **Automatic & Built-in** |
| **Scalability** | None                            | None                            | **Built-in & Self-Healing** |
| **Maintenance/Updates** | Manual CLI commands             | Manual CLI commands             | **Simple 1-Click Updates** |
| **Required Expertise** | Intermediate Docker             | Advanced Docker & Networking    | **Beginner-friendly** |

## Conclusion: Focus on Automation, Not Operations

Running n8n with Docker is a powerful way to control your automation infrastructure. The `docker run` and `docker compose` methods are viable for local testing, but they impose a steep learning curve and significant operational overhead that scales with your needs.

Sealos provides a vastly superior alternative by absorbing the underlying complexity. It empowers you to deploy a scalable, secure, and production-ready n8n instance in seconds. This allows you to focus your time and energy on building innovative workflows, not on managing servers and configuration files.